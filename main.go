package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	var flags flag.FlagSet
	opts := protogen.Options{ParamFunc: flags.Set}

	opts.Run(func(gen *protogen.Plugin) error {
		for _, file := range gen.Files {
			if !file.Generate {
				continue
			}

			filename := file.GeneratedFilenamePrefix + ".eventstream.pb.go"
			generatedFile := gen.NewGeneratedFile(filename, file.GoImportPath)

			generatedFile.P("// Code generated by protoc-gen-go-eventstream. DO NOT EDIT.")
			generatedFile.P()
			generatedFile.P("package ", file.GoPackageName)
			generatedFile.P()

			for _, msg := range file.Messages {
				generateForMessage(generatedFile, msg)
			}
		}
		return nil
	})
}

func generateForMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	if len(msg.Oneofs) == 0 {
		return
	}

	for _, oneof := range msg.Oneofs {
		if oneof.Desc.IsSynthetic() {
			continue
		}

		var eventFields []*protogen.Field
		for _, field := range oneof.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind {
				eventFields = append(eventFields, field)
			}
		}
		if len(eventFields) == 0 {
			continue
		}

		eventIfaceName := "is" + msg.GoIdent.GoName + "_" + oneof.GoName + "_Option"
		markerMethodName := eventIfaceName

		// --- Event interface ---
		g.P("// ", eventIfaceName, " is implemented by all domain-event messages carried by ", msg.GoIdent.GoName, ".")
		g.P("type ", eventIfaceName, " interface {")
		g.P("	", markerMethodName, "()")
		g.P("}")
		g.P()

		// --- Marker methods on event messages ---
		for _, field := range eventFields {
			eventMsg := field.Message
			g.P("// ", markerMethodName, " marks ", eventMsg.GoIdent.GoName, " as a valid ", msg.GoIdent.GoName, " event.")
			g.P("func (e *", eventMsg.GoIdent.GoName, ") ", markerMethodName, "() {}")
			g.P()
		}

		// type isEvtOption interface {
		// 	Evt() isNotificationPreferencesMsg_Evt
		// }
		g.P("type is", oneof.GoName, "Option interface {")
		g.P("    ", oneof.GoName, "() is", msg.GoIdent.GoName, "_", oneof.GoName)
		g.P("}")
		g.P()
		// --- Constructors: New<Opt>Message(...event fields...) *Wrapper ---
		for _, field := range eventFields {
			// generateConstructorForOneofOption(g, msg, oneof, field)
			generateOneofOptionWrapper(g, msg, oneof, field)
		}

		// --- Unwrapper: GetUnwrappedEvent() EventInterface ---
		generateUnwrapper(g, msg, oneof, eventFields, eventIfaceName)

		// Separate sections for readability if multiple oneofs exist.
		g.P()
	}
}

func generateOneofOptionWrapper(g *protogen.GeneratedFile, wrapper *protogen.Message, oneof *protogen.Oneof, opt *protogen.Field) {
	// func (x *MarketingEmailsConsentGranted) Evt() isNotificationPreferencesMsg_Evt {
	g.P("func (x *", opt.Message.GoIdent.GoName, ")", oneof.GoName, "() is", wrapper.GoIdent.GoName, "_", oneof.GoName, " {")
	g.P("    return &", wrapper.GoIdent.GoName+"_"+opt.GoName, "{")
	g.P("        ", opt.GoName, ": x,")
	g.P("    }")
	g.P("}")
}

func generateConstructorForOneofOption(g *protogen.GeneratedFile, wrapper *protogen.Message, oneof *protogen.Oneof, opt *protogen.Field) {
	// Example: NewMarketingEmailsConsentGrantedMessage(...)
	constructorName := "New" + opt.GoName

	// Event message type referenced by the oneof option.
	eventMsg := opt.Message

	// Build the function signature using the event message fields.
	// Example: (userId string) *NotificationPreferencesMessage
	g.P("// ", constructorName, " creates a new ", wrapper.GoIdent.GoName, " with ", opt.GoName, " set.")
	g.P("func ", constructorName, "(", signatureForEventFields(g, eventMsg), ") *", wrapper.GoIdent.GoName, " {")

	// Create the event instance and populate its fields.
	g.P("	e := &", eventMsg.GoIdent.GoName, "{")
	for _, f := range eventMsg.Fields {
		// Use the event field's GoName as the struct literal key, and a lowerCamel arg name as value.
		g.P("		", f.GoName, ": ", argName(f.GoName), ",")
	}
	g.P("	}")

	// Wrap it into the oneof wrapper struct generated by protoc-gen-go.
	// Wrapper struct type name: <Wrapper>_<OneofOptionGoName>
	//
	// Example:
	//   return &NotificationPreferencesMessage{
	//     Event: &NotificationPreferencesMessage_MarketingEmailsConsentGranted{
	//       MarketingEmailsConsentGranted: e,
	//     },
	//   }
	oneofFieldGoName := oneof.GoName // e.g. "Event"
	oneofWrapperType := wrapper.GoIdent.GoName + "_" + opt.GoName
	g.P("	return &", wrapper.GoIdent.GoName, "{")
	g.P("		", oneofFieldGoName, ": &", oneofWrapperType, "{")
	g.P("			", opt.GoName, ": e,")
	g.P("		},")
	g.P("	}")
	g.P("}")
	g.P()
}

func generateUnwrapper(
	g *protogen.GeneratedFile,
	wrapper *protogen.Message,
	oneof *protogen.Oneof,
	eventFields []*protogen.Field,
	eventIfaceName string,
) {
	// Example:
	// func (m *NotificationPreferencesMessage) GetUnwrappedEvent() IsNotificationPreferencesEvent
	// (returns nil if nothing is set)
	g.P("// GetUnwrappedEvent returns the concrete event message stored in the ", oneof.GoName, " oneof.")
	g.P("// It returns nil if no event is set.")
	g.P("func (m *", wrapper.GoIdent.GoName, ") GetUnwrapped", oneof.GoName, "() ", eventIfaceName, " {")
	g.P("if m == nil {")
	g.P("  return nil")
	g.P("}")

	// Accessor for the oneof interface generated by protoc-gen-go is: m.Get<OneofName>()
	// Example: m.GetEvent()
	getterName := "Get" + oneof.GoName

	g.P("	switch v := m.", getterName, "().(type) {")
	for _, field := range eventFields {
		oneofWrapperType := wrapper.GoIdent.GoName + "_" + field.GoName
		g.P("	case *", oneofWrapperType, ":")
		g.P("		return v.", field.GoName)
	}
	g.P("	default:")
	g.P("		return nil")
	g.P("	}")
	g.P("}")
	g.P()
}

// signatureForEventFields builds "UserId string, ..." based on the event message fields.
func signatureForEventFields(g *protogen.GeneratedFile, eventMsg *protogen.Message) string {
	parts := make([]string, 0, len(eventMsg.Fields))
	for _, f := range eventMsg.Fields {
		parts = append(parts, fmt.Sprintf("%s %s", argName(f.GoName), goTypeForField(g, f)))
	}
	return strings.Join(parts, ", ")
}

// goTypeForField maps a proto field to its Go type name as used by protoc-gen-go.
func goTypeForField(g *protogen.GeneratedFile, f *protogen.Field) string {
	// Repeated => []T
	if f.Desc.IsList() {
		elem := scalarOrNamedGoType(g, f)
		return "[]" + elem
	}

	// Map => map[K]V
	if f.Desc.IsMap() {
		key := mapKeyGoType(f.Desc.MapKey().Kind())
		valField := f.Message.Fields[1] // map entry: fields[0]=key, fields[1]=value
		val := goTypeForField(g, valField)
		return "map[" + key + "]" + val
	}

	return scalarOrNamedGoType(g, f)
}

func scalarOrNamedGoType(g *protogen.GeneratedFile, f *protogen.Field) string {
	switch f.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(f.Enum.GoIdent)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		// Messages are pointers in generated Go structs.
		return "*" + g.QualifiedGoIdent(f.Message.GoIdent)
	default:
		// Fallback for any kinds you didn't model yet.
		return "any"
	}
}

func mapKeyGoType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	default:
		// Protobuf map keys are restricted; this is just a safe fallback.
		return "string"
	}
}

// argName turns "UserId" into "userId" (simple lower-camel).
func argName(goName string) string {
	if goName == "" {
		return ""
	}
	return strings.ToLower(goName[:1]) + goName[1:]
}
